#!/bin/bash

HOST_FS_DIR='/media/dls'
CONT_FS_DIR='/dls'

CONT_NAME='php-sw'
RUN_NAME="run-${CONT_NAME}"
DOCKER_DIR=$(dirname $0)
THIS_SCRIPT=$(basename $0)

cd $(echo ${DOCKER_DIR} | sed 's/docker/SynchWeb/g')

HOST_WORK_DIR=$(pwd)
CONT_WORK_DIR='/var/www/sites/synchweb'

if [[ ${THIS_SCRIPT} != 'web' ]]
then
    TASK='shell'
    TTY=''
    WAIT_FAIL='fail'
    case ${THIS_SCRIPT} in
    'php')
        COMMAND="php $@"
        ;;
    phpcs|phpmd)
        COMMAND="lint-docker ${THIS_SCRIPT} ${HOST_WORK_DIR} ${CONT_WORK_DIR} $@"
        ;;
    esac
else
    echo Running from $(pwd)
    TASK='shell'
    TTY='--tty'
    WAIT_FAIL='wait'
    case $1 in
    'shell')
        COMMAND='bash'
        ;;
    'backend')
        COMMAND="php -S 0.0.0.0:8000"
        CONT_WORK_DIR="${CONT_WORK_DIR}/api"
        ;;
    'frontend')
        PROXY_TARGET="--env.proxy.target=${2:-http://0.0.0.0:8000}/"
        COMMAND="npm run serve -- ${PROXY_TARGET} --host=0.0.0.0"
        CONT_WORK_DIR="${CONT_WORK_DIR}/client"
        ;;
    'mysql')
        COMMAND="php /usr/local/bin/mysql-config.php ${CONT_WORK_DIR}"
        ;;
    *)
        TASK=$1
        ;;
    esac
fi

case $TASK in
'run')
    docker build --tag ${CONT_NAME} ${DOCKER_DIR}

    if [ "$(ls -A ${HOST_FS_DIR})" ]
    then
        echo 'network FS dir already mounted'
    else
        echo 'Mounting network FS dir'
        mount ${HOST_FS_DIR}
    fi

    # I need to inject DNS servers into the contaner so that It can "see"
    # The database servers that I'm accessing through a VPN
    DNS_SERVERS=$(
        for CONNECTION in $(
            nmcli --terse --fields UUID connection show --active
        )
        do
            nmcli --terse -fields IP4.DNS connection show ${CONNECTION}
        done | awk -F: '{ print "--dns " $2 }'
    )

    docker run \
        --rm --interactive --tty \
        --workdir ${CONT_WORK_DIR} \
        --publish 8000:8000 \
        --publish 9000:9000 \
        ${DNS_SERVERS} \
        --user $(id -u):$(id -g) \
        --volume ${HOST_WORK_DIR}:${CONT_WORK_DIR} \
        --volume ${HOME}/.ssh:/home/dev/.ssh:ro \
        --volume ${HOST_FS_DIR}:/${CONT_FS_DIR} \
        --name ${RUN_NAME} \
        ${CONT_NAME} bash
    ;;
'shell')
    isNotRunning () {
        [[ $(docker container ls | grep ${RUN_NAME} | wc -l) == 0 ]]
    }

    case $WAIT_FAIL in
    'wait')
        while isNotRunning
        do
            sleep 0.1
        done
        ;;
    'fail')
        if isNotRunning
        then
            echo container not running >&2
            exit 1
        fi
        ;;
    esac

    docker container exec \
        --interactive ${TTY} \
        --workdir ${CONT_WORK_DIR} \
        ${RUN_NAME} ${COMMAND}
    ;;
*)
    echo -e "\n\nrun from the project working directory\n"
    echo "../docker/web run                       start container"
    echo "../docker/web shell                     bash"
    echo "../docker/web backend                   PHP dev. server"
    echo "../docker/web frontend {backend server} Webpack dev. server"
    echo "../docker/phpcs                         run php code sniffer"
    echo "../docker/phpmd                         run php mess detector"
    ;;
esac
